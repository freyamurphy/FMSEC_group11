theory P1 
begin

builtins: symmetric-encryption

// Key infrastructure
rule Register_Key:
    [ Fr(~k) ] // Fresh key
--[]->
    [ !Ltk($X, ~k) ]

rule Reveal_ltk:
  [ !Ltk(A, ltkA) ] --[ Reveal(A) ]-> [ Out(ltkA) ]

/* Formalise protocol P1
    1. A -> B: x
    2. A <- B: {x}k(A, B)
  }
*/

rule Init_A:
  [ Fr(~id) // Fresh id for A
  , !Ltk($A, ltkAB) // Persistant long-term key A->B
  , !Ltk($B, ltkBA) // Persistant long-term key B->A
  ]
--[ Create_A($A, ~id) ]->
  [ St_A_1($A, ~id, ltkAB, ltkBA, $B)
  ]

rule Init_B:
  [ Fr(~id) // Fresh id for B
  , !Ltk($A, ltkAB) // Persistant long-term key A->B
  , !Ltk($B, ltkBA) // Persistant long-term key B->A
  ]
--[ Create_B($B, ~id) ]->
  [ St_B_1($B, ~id, ltkBA, ltkAB, $A)
  ]

rule A_1_send:
  [ St_A_1($A, ~id, ltkAB, ltkBA, $B) 
  , Fr(~x) // Fresh nonce x
  ]
--[ Send($A, ~x) ]-> // A sends x
  [ St_A_2($A, ~id, ltkAB, ltkBA, $B, ~x) 
  , Out(~x)
  ]

rule B_1_receive:
  [ St_B_1($B, ~id, ltkBA, ltkAB, $A)
  , In(x)
  ]
--[ Recv($B, x)
  , Running($B, $A, <'I', 'R', x) 
  , Honest($A)
  ]->
  [ St_B_2($B, ~id, ltkBA, ltkAB, $A, x)
  ]

rule B_2_send:
  let mB2 = senc(x, ltkBA)
  in
  [ St_B_2($B, ~id, ltkBA, ltkAB, $A, x)
  ]
--[ Send($B, mB2) ]->
  [ St_B_3($B, ~id, ltkBA, ltkAB, $A, x)
  , Out(mB2)
  ]

rule A_2_receive:
  let mA2 = senc(m, ltkBA)
  in
  [ St_A_2($A, ~id, ltkAB, ltkBA, $B, ~x) 
  , In(mA2)
  ]
--[ Rcv($A, mA2) 
  , Commit($A, $B, <'I', 'R', m>)
  , Honest($B)
  , Finish()
  ]->
  [ St_A_3($A, ~id, ltkAB, ltkBA, $B, ~x, m) 
  ]

/* Lemmas to prove */
lemma executable:
  exists-trace
    "Ex #i. Finish() @i
    "
lemma injectiveagreementINITIATOR:
  "All a b t #i. 
    Commit(a,b,<'I','R',t>) @i
    ==> (Ex #j. Running(b,a,<'I','R',t>) @j 
        & not (Ex a2 b2 #i2. Commit(a2,b2,<'I','R',t>) @i2
                           & not (#i2 = #i)))
              | (Ex X #r. Reveal(X)@r & Honest(X) @i)"
end