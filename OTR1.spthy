theory OTR1
begin

builtins: 
  diffie-hellman, 
  signing

/*** Key Infrastructure ***/

/* Register signing/verification key pair. 
 * ltk is the secret signing key
 * pk(ltk) is the public verification key
 */
rule Register_key_pair:
  [ Fr(~ltk) ]
--[]->
  [ !Ltk($A, ~ltk)
  , !Pk($A, pk(~ltk))
  , Out(pk(~ltk))
  ]

// Agent is compromised and its secret signing key is revealed
rule Reveal_ltk:
  [ !Ltk(A, ltk) ]
--[ Reveal(A) ]->
  [ Out(ltk) ]

/*** Formalise OTR Authentic Key-Exchange ***
 * 1. A -> B : g^x, {g^x}sk_A, vk_A
 * 2. B -> A : g^y, {g^y}sk_B, vk_B
 */

// Initialise thread for initiator role
rule Init_A:
  [ Fr(~id) 
  , !Ltk(A, ltkA) // A's signing key
  , !Pk(B, pkB)   // B's verification key
  ]
--[ Create_A(A, ~id) ]->
  [ St_A_1(A, ~id, ltkA, pkB, B) ]

// Initialise thread for responder role
rule Init_B:
  [ Fr(~id)
  , !Ltk(B, ltkB) // B's signing key
  , !Pk(A, pkA)   // A's verification key
  ]
--[ Create_B(B, ~id) ]->
  [ St_B_1(B, ~id, ltkB, pkA, A) ]

// Step 1.1: A sends g^x to B
rule A_1_send:
  let m = <$g^~x, sign($g^~x, ltkA), pk(ltkA)>
  in
  [ St_A_1(A, id, ltkA, pkB, B) 
  , Fr(~x)
  ]
--[ Send(A, m) ]->
  [ St_A_2(A, id, ltkA, pkB, B, $g, ~x)
  , Out(m)
  ]

// Step 1.2: B receives g^x from A
rule B_1_receive:
  let m = <gx, signature, pkA>
  in
  [ St_B_1(B, id, ltkB, pkA, A)
  , In(m)
  ]
--[ Recv(B, m) ]->
  [ St_B_2(B, id, ltkB, pkA, A, gx) ]

// Step 2.1: B sends g^y to A
rule B_2_send:
  let m = <$g^~y, sign($g^~y, ltkB), pk(ltkB)>
  in
  [ St_B_2(B, id, ltkB, pkA, A, gx)
  , Fr(~y)
  ]
--[ Send(B, m) ]->
  [ St_B_3(B, id, ltkB, pkA, A, gx, $g, ~y)
  , Out(m)
  ]

// Step 2.2: A receives g^y from B
rule A_2_receive:
  let m = <gy, signature, pkB>
  in
  [ St_A_2(A, id, ltkA, pkB, B, g, x)
  , In(m)
  ]
--[ Recv(A, m) ]->
  [ St_A_3(A, id, ltkA, pkB, B, g, x, gy) ]

end